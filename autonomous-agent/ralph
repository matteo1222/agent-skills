#!/bin/bash
#
# RALPH - Relentless Autonomous Loop for Proactive Hacking
#
# Inspired by the Ralph Wiggum technique:
# "Me fail English? That's unpossible!"
#
# Philosophy: Keep trying until you succeed.
# Deterministically iterate in an undeterministic world.
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
STATE_DIR="${SCRIPT_DIR}/.state"
MEMORY_DIR="${SCRIPT_DIR}/memory"
DIRECTOR_FILE="${SCRIPT_DIR}/director.yaml"
LOG_FILE="${STATE_DIR}/ralph.log"
MEMORY_SCRIPT="${SCRIPT_DIR}/memory.sh"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Default configuration
AGENT="${RALPH_AGENT:-claude}"
MAX_ITERATIONS="${RALPH_MAX_ITERATIONS:-100}"
MAX_COST="${RALPH_MAX_COST:-10.00}"
TIMEOUT_HOURS="${RALPH_TIMEOUT_HOURS:-4}"
AUTO_APPROVE="${RALPH_AUTO_APPROVE:-false}"
DRY_RUN=false
ONCE=false
OUTPUT_FILE=""
SCHEDULE=""

# Parse command line arguments
usage() {
    echo "Usage: ralph <mission-file> [options]"
    echo "       ralph --memory [command]"
    echo "       ralph --director"
    echo ""
    echo "Options:"
    echo "  --agent <name>      Agent to use: claude, gemini, q (default: claude)"
    echo "  --max-iter <n>      Maximum iterations (default: 100)"
    echo "  --max-cost <n>      Maximum cost in dollars (default: 10.00)"
    echo "  --timeout <n>       Timeout in hours (default: 4)"
    echo "  --auto-approve      Auto-approve all actions"
    echo "  --dry-run           Preview actions without executing"
    echo "  --once              Run once and exit"
    echo "  --schedule <when>   Schedule: hourly, daily, weekly"
    echo "  --output <file>     Output report to file"
    echo "  --director          Edit director.yaml configuration"
    echo "  --memory            Show memory summary (or pass command to memory.sh)"
    echo "  --help              Show this help"
    exit 1
}

MISSION_FILE=""

# Handle special commands first
if [[ "$1" == "--memory" ]]; then
    shift
    if [[ $# -eq 0 ]]; then
        exec "$MEMORY_SCRIPT" summary
    else
        exec "$MEMORY_SCRIPT" "$@"
    fi
fi

if [[ "$1" == "--director" ]]; then
    echo -e "${BLUE}Director configuration: ${DIRECTOR_FILE}${NC}"
    echo ""
    if [[ -f "$DIRECTOR_FILE" ]]; then
        cat "$DIRECTOR_FILE"
    else
        echo "No director.yaml found. Creating from template..."
        # The file should already exist, but show the path
    fi
    echo ""
    echo -e "${YELLOW}Edit this file to set your general direction, goals, and seed sources.${NC}"
    exit 0
fi

while [[ $# -gt 0 ]]; do
    case $1 in
        --agent) AGENT="$2"; shift 2 ;;
        --max-iter) MAX_ITERATIONS="$2"; shift 2 ;;
        --max-cost) MAX_COST="$2"; shift 2 ;;
        --timeout) TIMEOUT_HOURS="$2"; shift 2 ;;
        --auto-approve) AUTO_APPROVE=true; shift ;;
        --dry-run) DRY_RUN=true; shift ;;
        --once) ONCE=true; MAX_ITERATIONS=1; shift ;;
        --schedule) SCHEDULE="$2"; shift 2 ;;
        --output) OUTPUT_FILE="$2"; shift 2 ;;
        --help) usage ;;
        -*) echo "Unknown option: $1"; usage ;;
        *) MISSION_FILE="$1"; shift ;;
    esac
done

if [[ -z "$MISSION_FILE" ]]; then
    echo -e "${RED}Error: No mission file specified${NC}"
    usage
fi

if [[ ! -f "$MISSION_FILE" ]]; then
    echo -e "${RED}Error: Mission file not found: $MISSION_FILE${NC}"
    exit 1
fi

# Initialize state directory
mkdir -p "$STATE_DIR"

# Logging function
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"

    case $level in
        INFO)  echo -e "${BLUE}[$level]${NC} $message" ;;
        OK)    echo -e "${GREEN}[$level]${NC} $message" ;;
        WARN)  echo -e "${YELLOW}[$level]${NC} $message" ;;
        ERROR) echo -e "${RED}[$level]${NC} $message" ;;
        LOOP)  echo -e "${PURPLE}[$level]${NC} $message" ;;
    esac
}

# Parse YAML mission file (simple parser)
parse_yaml() {
    local yaml_file="$1"
    local prefix="${2:-}"

    # Use a simple approach - just extract key values
    while IFS=':' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue

        # Clean up key and value
        key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | tr '-' '_')
        value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/^"//;s/"$//')

        # Export as environment variable
        if [[ -n "$value" && ! "$key" =~ ^- ]]; then
            export "MISSION_${prefix}${key^^}"="$value"
        fi
    done < "$yaml_file"
}

# Load mission configuration
log INFO "Loading mission: $MISSION_FILE"
parse_yaml "$MISSION_FILE"

MISSION_NAME="${MISSION_NAME:-Unnamed Mission}"
log INFO "Mission: $MISSION_NAME"

# Load director configuration
load_director() {
    if [[ -f "$DIRECTOR_FILE" ]]; then
        cat "$DIRECTOR_FILE"
    else
        echo "(No director.yaml found - using mission defaults)"
    fi
}

# Get memory context
get_memory_context() {
    if [[ -x "$MEMORY_SCRIPT" ]]; then
        "$MEMORY_SCRIPT" export-for-prompt 2>/dev/null || echo "(No memory yet)"
    else
        echo "(Memory system not initialized)"
    fi
}

# Record experiment start
start_experiment() {
    local name="$1"
    local hypothesis="$2"
    local focus="$3"

    if [[ -x "$MEMORY_SCRIPT" ]]; then
        "$MEMORY_SCRIPT" add-experiment "$name" "$hypothesis" "$focus" 2>/dev/null
    fi
}

# Record experiment completion
complete_experiment() {
    local id="$1"
    local outcome="$2"
    local learnings="$3"

    if [[ -x "$MEMORY_SCRIPT" ]]; then
        "$MEMORY_SCRIPT" complete-experiment "$id" "$outcome" "$learnings" 2>/dev/null
    fi
}

# Generate the prompt for the agent
generate_prompt() {
    local iteration="$1"
    local mission_file="$2"

    # Get director and memory context
    local director_config=$(load_director)
    local memory_context=$(get_memory_context)

    cat << EOF
You are an autonomous agent running iteration $iteration of a proactive improvement mission.

# ═══════════════════════════════════════════════════════════════════════════════
# DIRECTOR: Your General Direction
# ═══════════════════════════════════════════════════════════════════════════════

$director_config

# ═══════════════════════════════════════════════════════════════════════════════
# MISSION: Current Task
# ═══════════════════════════════════════════════════════════════════════════════

$(cat "$mission_file")

# ═══════════════════════════════════════════════════════════════════════════════
# MEMORY: What You've Learned
# ═══════════════════════════════════════════════════════════════════════════════

$memory_context

# ═══════════════════════════════════════════════════════════════════════════════
# YOUR TASK
# ═══════════════════════════════════════════════════════════════════════════════

## Phase 1: RESEARCH
1. Check memory for what was already tried - DON'T REPEAT FAILURES
2. Use seed sources from director.yaml as starting points
3. Search for SIMILAR sources to the seeds (same quality, same perspective)
4. Look for the latest trends and best practices

## Phase 2: ANALYZE
1. Compare findings with current state (codebase, website, business)
2. Consider the director's focus areas and their weights
3. Prioritize based on north star metrics
4. Respect the constraints and principles

## Phase 3: ACT
Based on the mission's action type:
- **report**: Write findings to a markdown file
- **prototype**: Create a working prototype in ./prototypes/
- **pr**: Create a branch and make changes, then report what you'd PR
- **direct_edit**: Make the improvements directly (if auto-approve is on)

## Phase 4: REMEMBER
After completing your work, record what you learned:

1. Write a brief experiment record:
   \`\`\`bash
   # Record what you tried
   ${MEMORY_SCRIPT} add-experiment "experiment name" "hypothesis" "focus_area"

   # When done, record outcome
   ${MEMORY_SCRIPT} complete-experiment "ID" "success|failure|partial" "learnings separated by semicolons"

   # Add any discovered sources
   ${MEMORY_SCRIPT} add-source "url" "type" "why useful" "found from"

   # Record key insights
   ${MEMORY_SCRIPT} add-insight "category" "the insight" "evidence"
   \`\`\`

2. Write iteration results to: ${STATE_DIR}/iteration_${iteration}_results.md

3. If mission complete, create: ${STATE_DIR}/MISSION_COMPLETE

## Current State

- Iteration: $iteration of $MAX_ITERATIONS
- Dry Run: $DRY_RUN
- Auto Approve: $AUTO_APPROVE
- Working Directory: $(pwd)
- Memory Directory: $MEMORY_DIR

## Key Principles

1. **Don't repeat failures** - Check memory first
2. **Build on successes** - Do more of what works
3. **Discover similar sources** - Expand from seed sources
4. **Record everything** - Future iterations depend on your notes
5. **Be specific** - Generic advice is useless; find concrete improvements
EOF
}

# Check if mission is complete
is_complete() {
    [[ -f "${STATE_DIR}/MISSION_COMPLETE" ]]
}

# Run the agent
run_agent() {
    local prompt="$1"
    local prompt_file="${STATE_DIR}/current_prompt.md"

    echo "$prompt" > "$prompt_file"

    case "$AGENT" in
        claude)
            if command -v claude &> /dev/null; then
                claude --print "$prompt" 2>&1
            else
                log ERROR "Claude CLI not found. Install with: npm install -g @anthropic-ai/claude-code"
                return 1
            fi
            ;;
        gemini)
            if command -v gemini &> /dev/null; then
                gemini "$prompt" 2>&1
            else
                log ERROR "Gemini CLI not found"
                return 1
            fi
            ;;
        *)
            log ERROR "Unknown agent: $AGENT"
            return 1
            ;;
    esac
}

# Calculate schedule delay
get_schedule_delay() {
    case "$SCHEDULE" in
        hourly) echo 3600 ;;
        daily) echo 86400 ;;
        weekly) echo 604800 ;;
        *) echo 0 ;;
    esac
}

# Main loop - THE RALPH WIGGUM TECHNIQUE
main_loop() {
    local iteration=1
    local start_time=$(date +%s)
    local timeout_seconds=$((TIMEOUT_HOURS * 3600))
    local total_cost=0
    local consecutive_failures=0
    local max_failures=5

    log LOOP "Starting Ralph Loop"
    log INFO "Agent: $AGENT"
    log INFO "Max iterations: $MAX_ITERATIONS"
    log INFO "Max cost: \$$MAX_COST"
    log INFO "Timeout: ${TIMEOUT_HOURS}h"

    # Clear previous state if starting fresh
    rm -f "${STATE_DIR}/MISSION_COMPLETE"

    while true; do
        # Check termination conditions
        if is_complete; then
            log OK "Mission complete!"
            break
        fi

        if [[ $iteration -gt $MAX_ITERATIONS ]]; then
            log WARN "Max iterations ($MAX_ITERATIONS) reached"
            break
        fi

        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        if [[ $elapsed -gt $timeout_seconds ]]; then
            log WARN "Timeout (${TIMEOUT_HOURS}h) reached"
            break
        fi

        if [[ $consecutive_failures -ge $max_failures ]]; then
            log ERROR "Too many consecutive failures ($max_failures)"
            break
        fi

        # Run iteration
        log LOOP "═══════════════════════════════════════════"
        log LOOP "Iteration $iteration"
        log LOOP "═══════════════════════════════════════════"

        local prompt=$(generate_prompt "$iteration" "$MISSION_FILE")

        if $DRY_RUN; then
            log INFO "[DRY RUN] Would execute agent with prompt:"
            echo "$prompt" | head -20
            echo "..."
            ((iteration++))
            continue
        fi

        # Execute the agent
        local output
        if output=$(run_agent "$prompt" 2>&1); then
            log OK "Iteration $iteration completed"
            echo "$output" > "${STATE_DIR}/iteration_${iteration}_output.txt"
            consecutive_failures=0
        else
            log ERROR "Iteration $iteration failed"
            ((consecutive_failures++))
            sleep $((2 ** consecutive_failures))  # Exponential backoff
        fi

        ((iteration++))

        # If running once, exit after first iteration
        if $ONCE; then
            break
        fi

        # If scheduled, wait between iterations
        local delay=$(get_schedule_delay)
        if [[ $delay -gt 0 ]]; then
            log INFO "Scheduled run - waiting ${SCHEDULE} before next iteration"
            sleep $delay
        fi
    done

    log LOOP "═══════════════════════════════════════════"
    log LOOP "Ralph Loop Complete"
    log LOOP "Total iterations: $((iteration - 1))"
    log LOOP "═══════════════════════════════════════════"

    # Generate final report if output file specified
    if [[ -n "$OUTPUT_FILE" ]]; then
        generate_report > "$OUTPUT_FILE"
        log OK "Report written to: $OUTPUT_FILE"
    fi
}

# Generate a summary report
generate_report() {
    echo "# Ralph Mission Report"
    echo ""
    echo "**Mission:** $MISSION_NAME"
    echo "**Date:** $(date)"
    echo "**Agent:** $AGENT"
    echo ""
    echo "## Iteration Results"
    echo ""

    for result_file in "${STATE_DIR}"/iteration_*_results.md; do
        if [[ -f "$result_file" ]]; then
            echo "---"
            cat "$result_file"
            echo ""
        fi
    done
}

# Handle Ctrl+C gracefully
trap 'log WARN "Interrupted by user"; exit 130' INT

# Banner
echo ""
echo -e "${PURPLE}╔═══════════════════════════════════════════════════════╗${NC}"
echo -e "${PURPLE}║                                                       ║${NC}"
echo -e "${PURPLE}║   ${YELLOW}RALPH${PURPLE} - Relentless Autonomous Loop                 ║${NC}"
echo -e "${PURPLE}║           for Proactive Hacking                       ║${NC}"
echo -e "${PURPLE}║                                                       ║${NC}"
echo -e "${PURPLE}║   ${NC}\"Me fail English? That's unpossible!\"${PURPLE}              ║${NC}"
echo -e "${PURPLE}║                                                       ║${NC}"
echo -e "${PURPLE}╚═══════════════════════════════════════════════════════╝${NC}"
echo ""

# Show memory status
if [[ -x "$MEMORY_SCRIPT" ]]; then
    exp_count=$(jq '.experiments | length' "${MEMORY_DIR}/experiments.json" 2>/dev/null || echo "0")
    source_count=$(jq '.discovered_sources | length' "${MEMORY_DIR}/sources.json" 2>/dev/null || echo "0")
    insight_count=$(jq '.insights | length' "${MEMORY_DIR}/insights.json" 2>/dev/null || echo "0")
    echo -e "${BLUE}Memory:${NC} $exp_count experiments, $source_count sources, $insight_count insights"
    echo ""
fi

# Run the main loop
main_loop
