#!/bin/bash
#
# RALPH - Relentless Autonomous Loop for Proactive Hacking
#
# Inspired by the Ralph Wiggum technique:
# "Me fail English? That's unpossible!"
#
# Philosophy: Keep trying until you succeed.
# Deterministically iterate in an undeterministic world.
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
STATE_DIR="${SCRIPT_DIR}/.state"
LOG_FILE="${STATE_DIR}/ralph.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Default configuration
AGENT="${RALPH_AGENT:-claude}"
MAX_ITERATIONS="${RALPH_MAX_ITERATIONS:-100}"
MAX_COST="${RALPH_MAX_COST:-10.00}"
TIMEOUT_HOURS="${RALPH_TIMEOUT_HOURS:-4}"
AUTO_APPROVE="${RALPH_AUTO_APPROVE:-false}"
DRY_RUN=false
ONCE=false
OUTPUT_FILE=""
SCHEDULE=""

# Parse command line arguments
usage() {
    echo "Usage: ralph <mission-file> [options]"
    echo ""
    echo "Options:"
    echo "  --agent <name>      Agent to use: claude, gemini, q (default: claude)"
    echo "  --max-iter <n>      Maximum iterations (default: 100)"
    echo "  --max-cost <n>      Maximum cost in dollars (default: 10.00)"
    echo "  --timeout <n>       Timeout in hours (default: 4)"
    echo "  --auto-approve      Auto-approve all actions"
    echo "  --dry-run           Preview actions without executing"
    echo "  --once              Run once and exit"
    echo "  --schedule <when>   Schedule: hourly, daily, weekly"
    echo "  --output <file>     Output report to file"
    echo "  --help              Show this help"
    exit 1
}

MISSION_FILE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --agent) AGENT="$2"; shift 2 ;;
        --max-iter) MAX_ITERATIONS="$2"; shift 2 ;;
        --max-cost) MAX_COST="$2"; shift 2 ;;
        --timeout) TIMEOUT_HOURS="$2"; shift 2 ;;
        --auto-approve) AUTO_APPROVE=true; shift ;;
        --dry-run) DRY_RUN=true; shift ;;
        --once) ONCE=true; MAX_ITERATIONS=1; shift ;;
        --schedule) SCHEDULE="$2"; shift 2 ;;
        --output) OUTPUT_FILE="$2"; shift 2 ;;
        --help) usage ;;
        -*) echo "Unknown option: $1"; usage ;;
        *) MISSION_FILE="$1"; shift ;;
    esac
done

if [[ -z "$MISSION_FILE" ]]; then
    echo -e "${RED}Error: No mission file specified${NC}"
    usage
fi

if [[ ! -f "$MISSION_FILE" ]]; then
    echo -e "${RED}Error: Mission file not found: $MISSION_FILE${NC}"
    exit 1
fi

# Initialize state directory
mkdir -p "$STATE_DIR"

# Logging function
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"

    case $level in
        INFO)  echo -e "${BLUE}[$level]${NC} $message" ;;
        OK)    echo -e "${GREEN}[$level]${NC} $message" ;;
        WARN)  echo -e "${YELLOW}[$level]${NC} $message" ;;
        ERROR) echo -e "${RED}[$level]${NC} $message" ;;
        LOOP)  echo -e "${PURPLE}[$level]${NC} $message" ;;
    esac
}

# Parse YAML mission file (simple parser)
parse_yaml() {
    local yaml_file="$1"
    local prefix="${2:-}"

    # Use a simple approach - just extract key values
    while IFS=':' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue

        # Clean up key and value
        key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | tr '-' '_')
        value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/^"//;s/"$//')

        # Export as environment variable
        if [[ -n "$value" && ! "$key" =~ ^- ]]; then
            export "MISSION_${prefix}${key^^}"="$value"
        fi
    done < "$yaml_file"
}

# Load mission configuration
log INFO "Loading mission: $MISSION_FILE"
parse_yaml "$MISSION_FILE"

MISSION_NAME="${MISSION_NAME:-Unnamed Mission}"
log INFO "Mission: $MISSION_NAME"

# Generate the prompt for the agent
generate_prompt() {
    local iteration="$1"
    local mission_file="$2"

    cat << EOF
You are an autonomous agent running iteration $iteration of a proactive improvement mission.

## Mission Configuration
$(cat "$mission_file")

## Your Task

Based on the mission above, you need to:

1. **RESEARCH**: Search the web and gather the latest information on the topics specified
2. **ANALYZE**: Compare findings with the current state (codebase, website, business)
3. **ACT**: Take the specified actions (report, prototype, PR, or direct edit)

## Current State

- Iteration: $iteration of $MAX_ITERATIONS
- Dry Run: $DRY_RUN
- Auto Approve: $AUTO_APPROVE
- Working Directory: $(pwd)

## Instructions

1. Start by researching the latest trends and best practices
2. Identify 3-5 concrete improvements or opportunities
3. Take action based on the mission's action type:
   - For "report": Write findings to a markdown file
   - For "prototype": Create a working prototype in ./prototypes/
   - For "pr": Create a branch and make changes, then report what you'd PR
   - For "direct_edit": Make the improvements directly (if auto-approve is on)

4. When you're done with this iteration, write your findings to:
   ${STATE_DIR}/iteration_${iteration}_results.md

5. If the mission is complete (no more improvements to make), create a file:
   ${STATE_DIR}/MISSION_COMPLETE

## Available Tools

You have access to:
- Web search for research
- File reading/writing for analysis and reports
- Code editing for making changes
- Git for version control

Be proactive! Find real, actionable improvements. Don't just list generic advice.
Focus on specific, implementable changes that will have measurable impact.
EOF
}

# Check if mission is complete
is_complete() {
    [[ -f "${STATE_DIR}/MISSION_COMPLETE" ]]
}

# Run the agent
run_agent() {
    local prompt="$1"
    local prompt_file="${STATE_DIR}/current_prompt.md"

    echo "$prompt" > "$prompt_file"

    case "$AGENT" in
        claude)
            if command -v claude &> /dev/null; then
                claude --print "$prompt" 2>&1
            else
                log ERROR "Claude CLI not found. Install with: npm install -g @anthropic-ai/claude-code"
                return 1
            fi
            ;;
        gemini)
            if command -v gemini &> /dev/null; then
                gemini "$prompt" 2>&1
            else
                log ERROR "Gemini CLI not found"
                return 1
            fi
            ;;
        *)
            log ERROR "Unknown agent: $AGENT"
            return 1
            ;;
    esac
}

# Calculate schedule delay
get_schedule_delay() {
    case "$SCHEDULE" in
        hourly) echo 3600 ;;
        daily) echo 86400 ;;
        weekly) echo 604800 ;;
        *) echo 0 ;;
    esac
}

# Main loop - THE RALPH WIGGUM TECHNIQUE
main_loop() {
    local iteration=1
    local start_time=$(date +%s)
    local timeout_seconds=$((TIMEOUT_HOURS * 3600))
    local total_cost=0
    local consecutive_failures=0
    local max_failures=5

    log LOOP "Starting Ralph Loop"
    log INFO "Agent: $AGENT"
    log INFO "Max iterations: $MAX_ITERATIONS"
    log INFO "Max cost: \$$MAX_COST"
    log INFO "Timeout: ${TIMEOUT_HOURS}h"

    # Clear previous state if starting fresh
    rm -f "${STATE_DIR}/MISSION_COMPLETE"

    while true; do
        # Check termination conditions
        if is_complete; then
            log OK "Mission complete!"
            break
        fi

        if [[ $iteration -gt $MAX_ITERATIONS ]]; then
            log WARN "Max iterations ($MAX_ITERATIONS) reached"
            break
        fi

        local current_time=$(date +%s)
        local elapsed=$((current_time - start_time))
        if [[ $elapsed -gt $timeout_seconds ]]; then
            log WARN "Timeout (${TIMEOUT_HOURS}h) reached"
            break
        fi

        if [[ $consecutive_failures -ge $max_failures ]]; then
            log ERROR "Too many consecutive failures ($max_failures)"
            break
        fi

        # Run iteration
        log LOOP "═══════════════════════════════════════════"
        log LOOP "Iteration $iteration"
        log LOOP "═══════════════════════════════════════════"

        local prompt=$(generate_prompt "$iteration" "$MISSION_FILE")

        if $DRY_RUN; then
            log INFO "[DRY RUN] Would execute agent with prompt:"
            echo "$prompt" | head -20
            echo "..."
            ((iteration++))
            continue
        fi

        # Execute the agent
        local output
        if output=$(run_agent "$prompt" 2>&1); then
            log OK "Iteration $iteration completed"
            echo "$output" > "${STATE_DIR}/iteration_${iteration}_output.txt"
            consecutive_failures=0
        else
            log ERROR "Iteration $iteration failed"
            ((consecutive_failures++))
            sleep $((2 ** consecutive_failures))  # Exponential backoff
        fi

        ((iteration++))

        # If running once, exit after first iteration
        if $ONCE; then
            break
        fi

        # If scheduled, wait between iterations
        local delay=$(get_schedule_delay)
        if [[ $delay -gt 0 ]]; then
            log INFO "Scheduled run - waiting ${SCHEDULE} before next iteration"
            sleep $delay
        fi
    done

    log LOOP "═══════════════════════════════════════════"
    log LOOP "Ralph Loop Complete"
    log LOOP "Total iterations: $((iteration - 1))"
    log LOOP "═══════════════════════════════════════════"

    # Generate final report if output file specified
    if [[ -n "$OUTPUT_FILE" ]]; then
        generate_report > "$OUTPUT_FILE"
        log OK "Report written to: $OUTPUT_FILE"
    fi
}

# Generate a summary report
generate_report() {
    echo "# Ralph Mission Report"
    echo ""
    echo "**Mission:** $MISSION_NAME"
    echo "**Date:** $(date)"
    echo "**Agent:** $AGENT"
    echo ""
    echo "## Iteration Results"
    echo ""

    for result_file in "${STATE_DIR}"/iteration_*_results.md; do
        if [[ -f "$result_file" ]]; then
            echo "---"
            cat "$result_file"
            echo ""
        fi
    done
}

# Handle Ctrl+C gracefully
trap 'log WARN "Interrupted by user"; exit 130' INT

# Banner
echo ""
echo -e "${PURPLE}╔═══════════════════════════════════════════════════════╗${NC}"
echo -e "${PURPLE}║                                                       ║${NC}"
echo -e "${PURPLE}║   ${YELLOW}RALPH${PURPLE} - Relentless Autonomous Loop                 ║${NC}"
echo -e "${PURPLE}║           for Proactive Hacking                       ║${NC}"
echo -e "${PURPLE}║                                                       ║${NC}"
echo -e "${PURPLE}║   ${NC}\"Me fail English? That's unpossible!\"${PURPLE}              ║${NC}"
echo -e "${PURPLE}║                                                       ║${NC}"
echo -e "${PURPLE}╚═══════════════════════════════════════════════════════╝${NC}"
echo ""

# Run the main loop
main_loop
